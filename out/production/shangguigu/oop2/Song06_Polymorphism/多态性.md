## 面向对象特征之三 多态性

```
对象的多态性
    父类的引用指向子类的对象
 
理解多态性   
    一个事物的多种形态
    
Java中的多态性
    子类对象的多态性
        父类的引用指向子类的对象（子类的对象赋给父类的引用）

       在多态的场景下 调用方法时
            编译时  认为方法是左边的父类的类型方法（即被重写的方法）
            执行时  实际执行的是子类重写父类的方法
       
            编译看左边  执行看右边
            
    使用多态性的前提
        要有类的继承关系
        要有方法的重写
        
    多态的适用性
        适用于方法
        不适用于属性
        
    
    使用父类做方法的形参 是多态最多的使用场合
    即使增加了新的子类，方法也无需改变，提高了扩展性
    符合开闭原则
        对扩展开放 对修改关闭
            软件系统中的各个组件，如 模块、类、功能 应该在不修改现有的代码基础上 引入新功能 
            
    弊端    
        不能直接调用子类中特有的属性和方法（未重写的方法）  
            在多态的场景下。创建了子类的对象 也加载了子类特有的属性和方法
            但是由于声明为父类的引用，导致我们没有办法直接子类特有的属性和方法
            
```

### 向上转型（多态） 向下转型（强转）

```
多态就一定会有把子类对象赋值给父类变量的时候 这个时候在编译期间 就会出现类型转换的现象

但是使用父类变量接收子类对象后，就不能调用子类拥有 而父类没有的方法了

要想调用子类特有的方法 必须做类型转换，使得编译通过

向上转型
    当左边变量的类型（父类）大于 右边子类  称为向上转型
        此时 编译按照左边变量的类型，就只能调用父类中有的变量和方法 
        不能调用子类特有的变量和方法
        编译看左边 Base b = s;
        允许看右边     
    多态是运行时行为，不是编译时行为
        
向下转型
    可能会出现 类型转换异常
        java.lang.ClassCastException
        可以再向下转型之前 进行判断
        instanceof   判断左侧实例 是否是 右侧类 的实例
    转型后 就近原则  重写后的方法被优先调用
```


